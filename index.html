<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Camera Art Generator</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body, html { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background: #fff;
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            flex-direction: column;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #FF009E;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #666;
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>カメラへのアクセスを許可してください</div>
    </div>
    <div id="instructions">タップまたはクリックして開始</div>

    <script>
        // ===== 逻辑画布 =====
        let baseW = 900, baseH = 1600;

        // ===== 参数 =====
        let sampleSize = 4; // 网格采样步长
        let threshold = 300; // 感度阈值
        const pink = "#FF009E", purple = "#C05EA9", blue = "#B4E1E5";
        let currentColor = pink;

        // 摄像头
        const VIDEO_W = 240, VIDEO_H = 180;
        let video, started = false, cameraReady = false;

        // 实时暗区点
        let livePoints = [];
        let frameCounter = 0;
        const DETECT_EVERY = 6;

        // 冻结层
        let freezeLayers = [];

        // 倒计时
        let isFreezing = false, freezeStart = 0, freezeDuration = 1000;

        // UI
        const ui = {
            yTop: 140, dCircle: 80, rectH: 80, gap: 28, hitPad: 18,
            sensY: baseH - 140, sensR: 28, sensLinePad: 150,
        };
        const UI = {};
        
        function layoutUI() {
            let x = 40;
            UI.pink = { x, y: ui.yTop, w: ui.dCircle, h: ui.dCircle };
            x += ui.dCircle + ui.gap;
            UI.purple = { x, y: ui.yTop, w: ui.dCircle, h: ui.dCircle };
            x += ui.dCircle + ui.gap;
            UI.blue = { x, y: ui.yTop, w: ui.dCircle, h: ui.dCircle };
            x += ui.dCircle + ui.gap;
            UI.clear = { x, y: ui.yTop, w: 180, h: ui.rectH, label: "クリア" };
            x += 180 + ui.gap;
            UI.poster = { x, y: ui.yTop, w: 280, h: ui.rectH, label: "ポスター生成" };
            UI.sens = { x1: ui.sensLinePad, x2: baseW - ui.sensLinePad, y: ui.sensY, r: ui.sensR };
        }
        layoutUI();

        // 坐标换算：屏幕 → 基准
        function screenToBase(px, py) {
            const fit = Math.min(windowWidth / baseW, windowHeight / baseH);
            const offX = (windowWidth - baseW * fit) / 2;
            const offY = (windowHeight - baseH * fit) / 2;
            return { x: (px - offX) / fit, y: (py - offY) / fit };
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            pixelDensity(1);
            textSize(30);
            textAlign(CENTER, CENTER);
        }
        
        function windowResized() { 
            resizeCanvas(windowWidth, windowHeight); 
        }

        // iOS 需要手势启动摄像头
        function startCamera() {
            if (started) return;
            started = true;
            const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const constraints = {
                video: {
                    facingMode: isiOS ? "environment" : { exact: "environment" },
                    width: { ideal: VIDEO_W }, height: { ideal: VIDEO_H },
                },
                audio: false,
            };
            
            video = createCapture(constraints, () => {
                if (!video || !video.elt || !video.elt.srcObject) {
                    video = createCapture({ video: true, audio: false });
                }
                video.size(VIDEO_W, VIDEO_H);
                video.hide();
                if (video.elt && video.elt.play) {
                    video.elt.play().then(() => {
                        cameraReady = true;
                        document.getElementById('loading').style.display = 'none';
                    }).catch((err) => {
                        console.error("Camera error: ", err);
                        alert("カメラへのアクセスに失敗しました。ブラウザの設定を確認してください。");
                    });
                }
            });
            
            video.elt.addEventListener('error', () => {
                alert("カメラへのアクセスに失敗しました。ブラウザの設定を確認してください。");
            });
        }

        function draw() {
            background(255);
            const fit = Math.min(width / baseW, height / baseH);
            const offX = (width - baseW * fit) / 2, offY = (height - baseH * fit) / 2;
            push(); 
            translate(offX, offY); 
            scale(fit);

            if (!started || !cameraReady) {
                noStroke(); 
                fill(245); 
                rect(0, 0, baseW, baseH);
                fill(0); 
                textAlign(CENTER, CENTER); 
                textSize(36);
                text("タップして開始", baseW/2, baseH/2);
                pop(); 
                return;
            }

            drawReactiveDots();
            drawFrozenLayers();
            drawTopButtons();
            drawSensitivity();
            handleFreeze();

            pop();
        }

        /* ===== 实时点阵 ===== */
        function drawReactiveDots() {
            if (!video) return;
            if (frameCounter % DETECT_EVERY === 0) {
                livePoints.length = 0;
                video.loadPixels();
                if (video.pixels && video.pixels.length) {
                    const sx = video.width / baseW;
                    const sy = video.height / baseH;
                    for (let y = 0; y < baseH; y += sampleSize) {
                        const cy = (y * sy) | 0;
                        for (let x = 0; x < baseW; x += sampleSize) {
                            const cx = (x * sx) | 0;
                            const i = (cy * video.width + cx) * 4;
                            const s = video.pixels[i] + video.pixels[i+1] + video.pixels[i+2];
                            if (s < threshold) livePoints.push(x, y);
                        }
                    }
                }
            }
            frameCounter++;
            noStroke(); 
            fill(currentColor);
            const d = sampleSize * 0.8;
            for(let i = 0; i < livePoints.length; i += 2) {
                ellipse(livePoints[i], livePoints[i+1], d, d);
            }
        }

        function drawFrozenLayers() {
            const d = sampleSize * 0.8;
            for(const layer of freezeLayers) {
                fill(layer.color); 
                noStroke();
                const pts = layer.points;
                for(let i = 0; i < pts.length; i += 2) {
                    ellipse(pts[i], pts[i+1], d, d);
                }
            }
        }

        /* ===== UI ===== */
        function drawTopButtons() {
            drawCircle(UI.pink, pink);
            drawCircle(UI.purple, purple);
            drawCircle(UI.blue, blue);
            drawRect(UI.clear, "クリア", "#BCBCBC", "#000");
            drawRect(UI.poster, "ポスター生成", "#000", "#FFF");
        }
        
        function drawCircle(btn, col) {
            noStroke(); 
            fill(col);
            ellipse(btn.x + btn.w/2, btn.y + btn.h/2, btn.w, btn.h);
        }
        
        function drawRect(btn, label, bg, fg) {
            noStroke(); 
            fill(bg);
            rect(btn.x, btn.y, btn.w, btn.h, 12);
            fill(fg); 
            textAlign(CENTER, CENTER); 
            textSize(30);
            text(label, btn.x + btn.w/2, btn.y + btn.h/2);
        }
        
        function drawSensitivity() {
            const s = UI.sens;
            stroke(100); 
            strokeWeight(5); 
            noFill();
            line(s.x1, s.y, s.x2, s.y);
            const dotX = map(threshold, 0, 765, s.x1, s.x2, true);
            noStroke(); 
            fill(50);
            ellipse(dotX, s.y, s.r*2, s.r*2);
            fill(50); 
            textAlign(CENTER, BOTTOM); 
            textSize(26);
            text("感度: " + int(threshold), baseW/2, s.y - 20);
        }

        /* ===== 倒计时 ===== */
        function handleFreeze() {
            if (!isFreezing) return;
            let remain = freezeDuration - (millis() - freezeStart);
            fill(0, 180); 
            ellipse(baseW/2, baseH/2, 180, 180);
            fill(255); 
            textAlign(CENTER, CENTER); 
            textSize(68);
            text(Math.max(0, Math.ceil(remain/1000)), baseW/2, baseH/2);
            if (remain <= 0) { 
                captureCurrentFrame(); 
                isFreezing = false; 
            }
        }

        /* ===== 命中检测 ===== */
        function hitRect(btn, p) {
            const pad = ui.hitPad;
            return (p.x >= btn.x - pad && p.x <= btn.x + btn.w + pad &&
                    p.y >= btn.y - pad && p.y <= btn.y + btn.h + pad);
        }
        
        function hitCircle(btn, p) {
            const cx = btn.x + btn.w/2, 
                  cy = btn.y + btn.h/2,
                  r = Math.min(btn.w, btn.h)/2 + ui.hitPad;
            return dist(p.x, p.y, cx, cy) <= r;
        }

        /* ===== 交互 ===== */
        let draggingSensitivity = false;
        
        function handlePress(px, py) {
            if(!started) { 
                startCamera(); 
                document.getElementById('instructions').style.display = 'none';
                return true; 
            }
            const p = screenToBase(px, py);
            if(hitCircle(UI.pink, p)) { 
                currentColor = pink; 
                startFreeze(); 
                return true; 
            }
            if(hitCircle(UI.purple, p)) { 
                currentColor = purple; 
                startFreeze(); 
                return true; 
            }
            if(hitCircle(UI.blue, p)) { 
                currentColor = blue; 
                startFreeze(); 
                return true; 
            }
            if(hitRect(UI.clear, p)) { 
                freezeLayers = []; 
                return true; 
            }
            if(hitRect(UI.poster, p)) { 
                generatePosterHighRes(3); 
                return true; 
            }
            const s = UI.sens;
            if(p.y > s.y - s.r*2 && p.y < s.y + s.r*2 && p.x >= s.x1 && p.x <= s.x2) {
                threshold = int(map(p.x, s.x1, s.x2, 0, 765)); 
                draggingSensitivity = true; 
                return true;
            }
            const dotX = map(threshold, 0, 765, s.x1, s.x2, true);
            if(dist(p.x, p.y, dotX, s.y) <= s.r*1.5) { 
                draggingSensitivity = true; 
                return true; 
            }
            return false;
        }
        
        function handleDrag(px, py) {
            if(!draggingSensitivity) return false;
            const s = UI.sens, p = screenToBase(px, py);
            threshold = int(constrain(map(p.x, s.x1, s.x2, 0, 765), 0, 765)); 
            return true;
        }
        
        function handleRelease() { 
            draggingSensitivity = false; 
            return true; 
        }

        function mousePressed() { 
            return handlePress(mouseX, mouseY); 
        }
        
        function mouseDragged() { 
            return handleDrag(mouseX, mouseY); 
        }
        
        function mouseReleased() { 
            return handleRelease(); 
        }
        
        function touchStarted() { 
            const t = touches[0]; 
            if(t) return handlePress(t.x, t.y); 
            return false; 
        }
        
        function touchMoved() { 
            const t = touches[0]; 
            if(t) return handleDrag(t.x, t.y); 
            return false; 
        }
        
        function touchEnded() { 
            return handleRelease(); 
        }

        /* ===== 逻辑 ===== */
        function startFreeze() { 
            if(!isFreezing) { 
                isFreezing = true; 
                freezeStart = millis(); 
            } 
        }
        
        function captureCurrentFrame() {
            freezeLayers.push({ color: currentColor, points: livePoints.slice() });
        }

        /* ===== 导出 ===== */
        function downloadBlobPNG(canvas, filename) {
            const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            if(canvas.toBlob) {
                canvas.toBlob(function(blob) {
                    if(isiOS) {
                        const r = new FileReader();
                        r.onloadend = function() {
                            const w = window.open("");
                            if(w) w.document.write('<img src="' + r.result + '" style="width:100%;height:auto;"/>');
                        };
                        r.readAsDataURL(blob);
                    } else {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement("a");
                        a.href = url; 
                        a.download = filename;
                        document.body.appendChild(a); 
                        a.click();
                        requestAnimationFrame(() => { 
                            URL.revokeObjectURL(url); 
                            a.remove(); 
                        });
                    }
                }, "image/png");
            } else {
                const dataURL = canvas.toDataURL("image/png");
                const a = document.createElement("a");
                a.href = dataURL; 
                a.download = filename; 
                a.click();
            }
        }
        
        function generatePosterHighRes(scale = 3) {
            const pg = createGraphics(baseW * scale, baseH * scale);
            const d = sampleSize * 0.8 * scale;
            pg.noStroke();
            for(const layer of freezeLayers) {
                pg.fill(layer.color);
                const pts = layer.points;
                for(let i = 0; i < pts.length; i += 2) {
                    pg.ellipse(pts[i] * scale, pts[i+1] * scale, d, d);
                }
            }
            downloadBlobPNG(pg.canvas, `ポスター_${baseW*scale}x${baseH*scale}.png`);
            pg.remove();
        }
    </script>
</body>
</html>